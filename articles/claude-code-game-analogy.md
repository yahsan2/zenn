---
title: "ドラゴンを倒して覚える Claude Code - Command, Skill, Subagent, Rules"
emoji: "🎮"
type: "tech"
topics: ["claudecode", "llm", "ai"]
published: true
---

## この記事を読むべき人

Claude Code をカスタマイズしようとして、こんな経験はありませんか？

- 「このルール、CLAUDE.md に書く？Skill に書く？」と手が止まる
- Command を作ったのに、結局 Skill との違いがわからない
- Subagent の存在は知っているけど、いつ使うか判断できない

そして最近、**Rules** という機能まで登場しましたね。「また増えた...これどこに書くの？」

公式ドキュメントを読んでも、**概念の使い分け**がピンとこない。そんな人のために、RPGゲームで例えてみました。

:::message
この記事で扱う概念の公式ドキュメントはこちら:
- [Custom slash commands（Command）](https://code.claude.com/docs/en/slash-commands)
- [Agent Skills（Skill）](https://code.claude.com/docs/en/skills)
- [Subagents](https://code.claude.com/docs/en/sub-agents)
- [Modular rules（Rules）](https://code.claude.com/docs/en/memory#modular-rules-with-claude/rules/)
:::

## 冒険の始まり - あなたはプレイヤー

![](/images/claude-code-game-analogy/image_2.jpeg)

あなたはモンスターを倒すRPGをプレイしています。

画面の中には主人公のキャラクターがいます。あなたはプレイヤーとして、この主人公に指示を出してゲームを進めます。

**Claude Code で言うと：**
- **あなた（プレイヤー）** = ユーザー
- **主人公** = メインエージェント（Claude）

主人公は優秀なので、ざっくりした指示でも動いてくれます。ただし、毎回確認してきたり、考え込んだりします。

## 最初のモンスター - 毎回の確認が面倒

フィールドの少し先に、スライムがいるのを発見しました。
早速、主人公に倒してもらいます。


```
あなた: 「スライムを倒して」

主人公: 「スライムの位置を確認します...」
主人公: 「前方10歩先、左方向に3歩の場所にいますね」
主人公: 「近づきます」（歩いて近づく）
主人公: 「攻撃しますが、武器はどうしますか？」
主人公: 「剣、槍、斧がありますが...」

あなた: 「剣で」
主人公: （剣で攻撃）

スライムを倒した！
```

倒せました。でも、毎回これだと時間がかかります。

スライムを見つけるたびに「位置を確認...」「武器は？」とやっていては、冒険が進みません。

## Commandの登場 - 確認なしで動かす

そこで「攻撃」というコマンドを作ります。

**コマンド: `/attack [敵の名前]`**
- やること:
  - 敵の場所に向かう
  - 攻撃する
- 制約:
  - 確認は不要

これで、スライムを発見したら：

```
あなた: 「/attack スライム」
主人公: （スライムの場所に向かう → 攻撃）

スライムを倒した！
```

**確認も説明もなく、すぐに倒してくれました！**

これでスライムが何匹現れても、`/attack スライム` の一言で倒せます。快適です。

**Commandのポイント**:
- 毎回の確認や説明をスキップできる
- 指示は**主人公（メインエージェント）に対して**行われる
- 引数を渡せる（例: `/attack スライム`）

```md:.claude/commands/attack.md
---
description: 敵を攻撃する
argument-hint: [enemy]
---

$ARGUMENTS を倒してください。

- 敵の場所に向かう
- 攻撃する
- 確認は不要
```

:::details 現実世界での例
git操作をコマンド化しておけば、毎回の確認をスキップできます：

```md:.claude/commands/commit.md
---
description: 変更をコミットする
argument-hint: [メッセージ（省略可）]
---

変更をコミットしてください。

- git status で変更を確認
- $ARGUMENTS があればそれをメッセージに、なければ変更内容から自動生成
- ステージング → コミット
- 確認は不要
```

「/commit」の一言で、コミットしてくれます。
:::

Claude Code では、`.claude/commands/` にコマンドを定義します。

## ドラゴンの登場 - 剣が効かない敵

スライムは簡単に倒せるようになりました。さて、次はドラゴンを倒しに行きます。

主人公はドラゴンの居場所を知りませんが、あなたと一緒に試行錯誤し、ようやく火山にあるドラゴンの巣穴を探し出します。

```
あなた: 「先ほど調べた通りに火山に入って...」
主人公: （ようやくドラゴンの前に到着）

あなた: 「/attack」
主人公: （剣で攻撃）

ドラゴン: 「効かぬわ！」
```
![](/images/claude-code-game-analogy/image_4.jpeg)

剣では倒せません。主人公は調査をし見つけます。
ドラゴンには**サンダー魔法が弱点**だったのです。

## Skillの登場 - 特殊な能力を定義する

サンダー魔法を使うには、長い呪文を唱える必要があります。

```
あなた: 「インフィニティ・ライトニング・ストーム・
        アブソリュート・サンダー・ボルテージ・
        エクスプロージョン...」（まだまだ続く）

主人公: （サンダー魔法発動）
```

毎回これを言うのは大変すぎます。

そこで「サンダー魔法」というスキルを作ります。

```md:.claude/skills/thunder-magic/SKILL.md
---
name: thunder-magic
description: 雷属性の強力な魔法攻撃。ドラゴンに有効。
---

# サンダー魔法

## 詠唱の手順
1. 魔力を右手に集中させる
2. 「インフィニティ・ライトニング・ストーム...」と唱える
3. 雷雲が集まったら解放する

## 発動条件
- 魔力が十分にあること
- 屋外または天井が高い場所

## 効果
- 雷属性の攻撃を行う
- ドラゴン系に特効（2倍ダメージ）
```

これで：

```
あなた: 「サンダー魔法を使って」
主人公: （スキルを参照して、サンダー魔法発動）

ドラゴン: 「ぐわあああ！」
```

![](/images/claude-code-game-analogy/image_5.jpeg)
**ついにドラゴンを倒せました！**

長い呪文を覚えなくても、「サンダー魔法を使って」の一言で倒せます。

**Skillのポイント**:
- 複雑な手順や専門知識をまとめて定義できる
- 主人公に「どうやるか」を詳しく教えなくても、スキル名だけで実行できる
- サンダー魔法を使う時以外には、呪文を覚える必要がない（コンテキスト節約）

:::details 現実世界での例
gitのコミットメッセージの書き方は人やプロジェクトによって異なります。スキルとして定義しておけば：

```md:.claude/skills/git-commit-message/SKILL.md
---
name: git-commit-message
description: gitコミットメッセージの作成ルール
---

# コミットメッセージのルール

## フォーマット
- 1行目: 変更内容の要約（50文字以内）
- 2行目: 空行
- 3行目以降: 詳細な説明（必要に応じて）

## プレフィックス
- `feat:` 新機能
- `fix:` バグ修正
- `docs:` ドキュメント変更
- `refactor:` リファクタリング
```

「コミットして」というだけで、このルールに従ってコミットしてくれます。
:::

Claude Code では、`.claude/skills/` にスキルを定義します。

**SkillとCommandの簡単な違い**:
| 機能 | 例 | 役割 | 書く内容 |
|------|----|------| ----|
| **Command** | `/attack` | 何をやるか？ | タスク、CLIコマンド |
| **Skill** | `サンダー魔法` | どうやるか？ | 記述ルール、複雑な手順、専門知識、スクリプト |

このような区別をすると、すっきり分けられます。


## 初めてのSubagent - 魔法使いを仲間にする

サンダー魔法でドラゴンを倒せるようになりました。

しかし、ドラゴンはたくさんいます。主人公を操作して1匹ずつ倒しに行くのは効率が悪い。

そこで、あなたはパーティに新しい仲間を加えることにしました。

「魔法が得意な**魔法使い**を雇おう」

この魔法使いは、主人公とは別に動くキャラクターです。これがClaude Codeでいう**Subagent（サブエージェント）** です。

**サブエージェント: 魔法使い**
- 役割: 魔法で敵を攻撃することが得意
- 使えるスキル:
  - サンダー魔法
  - ファイアー魔法
  - ブリザド魔法

あなたは主人公に「魔法使いにドラゴンを倒させて」と指示します。

```
あなた: 「魔法使いにドラゴンを倒させて」
主人公: 「了解！」
主人公: 「魔法使い、ドラゴンを倒して」
魔法使い: （サンダー魔法発動）

ドラゴン: 「ぐわあああ！」
```

**魔法使いが自分でスキルを選んで、ドラゴンを倒してくれました！**

...と、うまくいけばいいのですが。

### 問題発生 - 魔法の選び方がわからない

先ほど魔法使いだからと、ついでにいろんな魔法を覚えさせました。すると、

```
あなた: 「魔法使いにドラゴンを倒させて」
主人公: 「了解！」
主人公: 「魔法使い、ドラゴンを倒して」
魔法使い: （ファイアー魔法発動）

ドラゴン: 「火は効かぬわ！」
```

あれ？魔法使いはファイアー魔法を使ってしまいました。

魔法は使えるけど、**どの敵にどの魔法が効くか**までは知らないのです。

### Subagentに「振る舞い」を追加する

そこで、魔法使いの設定に少しルールを書き足します。

**サブエージェント: 魔法使い（改善版）**
- 役割: 魔法で敵を攻撃することが得意
- 使えるスキル: サンダー魔法、ファイアー魔法、ブリザド魔法
- **振る舞い:**
  - ドラゴンにはサンダー魔法を優先
  - ゴーレムにはファイアー魔法を優先
  - 水棲系にはブリザド魔法を優先

これだけで、あなたはこう言うだけで良くなります。

```
あなた: 「魔法使いにドラゴンを倒させて」
主人公: 「了解！」
主人公: 「魔法使い、ドラゴンを倒して」
魔法使い: （相手はドラゴン → 弱点はサンダー → サンダー魔法発動）

ドラゴン: 「ぐわあああ！」
```
![](/images/claude-code-game-analogy/image_10.jpeg)

**適切な魔法を自分で判断して攻撃してくれるようになりました！**

Claude Code では、`.claude/agents/` にサブエージェントを定義します：

```md:.claude/agents/mage.md
---
name: mage
description: 魔法で敵を攻撃する。ドラゴン、ゴーレム、水棲系モンスターとの戦闘で使用する。
tools: Read, Bash
skills: thunder-magic, fire-magic, blizzard-magic
---

あなたは魔法攻撃の専門家です。

## 振る舞い
- ドラゴンにはサンダー魔法を優先
- ゴーレムにはファイアー魔法を優先
- 水棲系にはブリザド魔法を優先

敵の弱点を見極めて、最適な魔法を選択してください。
```

:::details 現実世界での例
コードレビューを担当するサブエージェントを定義できます：

```md:.claude/agents/code-reviewer.md
---
name: code-reviewer
description: コードの品質をチェックする。PR作成前やコード変更後に使用する。
tools: Read, Grep, Glob, Bash
skills: eslint-check, type-check, security-scan
---

あなたはコードレビューの専門家です。

## レビュー手順
1. まずeslint-checkでスタイルをチェック
2. 次にtype-checkで型エラーを確認
3. 最後にsecurity-scanで脆弱性をスキャン

## 出力形式
- 問題があれば具体的な修正案を提示
- 重大度（高/中/低）を明示
- 該当行番号を含める
```

「コードをレビューして」と言えば、この手順で自動的にレビューしてくれます。
:::
### 隣の戦場 - コンテキストの独立

実は、魔法使いに任せるメリットは２つあります。

主人公が一人で複数のドラゴンと戦うと、こうなります：

```
あなた: 「ドラゴン2体を倒して」
主人公: 「了解！」

（ドラゴンAの戦場へ向かう）
主人公: 「サンダー魔法！」（100ダメージ）
主人公: 「サンダー魔法！」（100ダメージ）
主人公: 「サンダー魔法！」（100ダメージ）
主人公: 「ドラゴンA撃破！よし、HP300だった」

（ドラゴンBの戦場へ向かう）
主人公: 「さっきのドラゴンはHP300だったから、こいつも3発で倒せるはず」
主人公: 「サンダー魔法！」（100ダメージ）
主人公: 「サンダー魔法！」（100ダメージ）
主人公: 「サンダー魔法！よし、倒した...あれ？」

ドラゴンB: 「まだHP100残ってるぞ！」（実はHP400だった）
ドラゴンB: （反撃）

主人公: 「うわあああ！」
```

**主人公は前の戦闘の情報に引きずられて、間違った判断をしてしまいました。**

一方、魔法使いに任せると：

```
あなた: 「魔法使いにドラゴンAを倒させて」
主人公: 「了解！」
主人公: 「魔法使い、ドラゴンAを倒して」

魔法使いA: （隣の戦場へ向かう）

------- 隣の戦場（主人公には見えない） -------
魔法使いA: 「サンダー魔法！」（100ダメージ）
魔法使いA: 「サンダー魔法！」（100ダメージ）
魔法使いA: 「サンダー魔法！」（100ダメージ）
---------------------------------------------

魔法使いA: 「ドラゴンAを倒しました」
主人公: 「了解！」

魔法使いB: （隣の戦場へ向かう）

------- 隣の戦場（主人公には見えない） -------
魔法使いB: 「サンダー魔法！」（100ダメージ）
魔法使いB: 「サンダー魔法！」（100ダメージ）
魔法使いB: 「サンダー魔法！」（100ダメージ）
---------------------------------------------

魔法使いB: 「ドラゴンBを倒しました」
主人公: 「了解！」
```

**主人公が知っているのは「倒した」という結果だけ。**

何発攻撃したか、残りHPがいくつだったかは知りません。魔法使いも別の戦場で独立して動いています。
でも、それでいいのです。主人公は前の戦闘に引きずられず、次の指示に集中できます。

### 並列処理 - Subagentの真価

さらにドラゴンは10匹います。当然1匹ずつ倒していくと...

```
あなた: 「魔法使いにドラゴンを倒させて」
主人公: 「了解！」
主人公: 「魔法使い、ドラゴンを倒して」
魔法使いA: （サンダー魔法発動）
ドラゴン1: 「ぐわあああ！」

魔法使いA: （サンダー魔法発動）
ドラゴン2: 「ぐわあああ！」

...（あと8回繰り返す）
```

**10匹倒すのに、10回待たないといけません。** 時間がかかりすぎます。

ここで、**Subagentの最大の強み**を紹介します。それは**並列で動かせる**ことです。

```
あなた: 「魔法使い10人で並列にドラゴンを全部倒させて」
主人公: 「了解！魔法使い10人、それぞれドラゴンを倒して！」

魔法使いA: （サンダー魔法発動）
魔法使いB: （サンダー魔法発動）
魔法使いC: （サンダー魔法発動）
...（同時に10発）

ドラゴン10匹: 「」（全員即死）
```

![](/images/claude-code-game-analogy/image_6.jpeg)

**10匹のドラゴンを一瞬で倒せました！**

主人公1人では1回ずつしか攻撃できませんが、サブエージェントを複数召喚すれば並列で処理できます。

**Subagentのポイント**:
- 特定の役割を持つ専門家を定義できる
- 主人公（メインエージェント）とは別に動く仲間（コンテキストが独立）
- 複数のスキルを組み合わせて使える
- 振る舞いを定義して、適切な判断をさせられる
- 並列で動かせる

## 新たな問題 - 道案内

ドラゴンを効率よく倒せるようになりました。

でも、まだ問題があります。魔法使いはドラゴンの**居場所**を知りません。

```
あなた: 「魔法使いにドラゴンを倒させて」
主人公: 「了解！」
主人公: 「魔法使い、ドラゴンを倒して」
魔法使い: 「どこにいるんですか？」
```


### 役割の分離 - 専門家を増やす
「ドラゴンの場所を見つけるスキル」を魔法使いに覚えさせることもできます。

しかし、モンスターはドラゴンだけではありません。
- ゴーレムの居場所
- リヴァイアサンの居場所
- スライムの居場所
- ...

全てのモンスターの道案内スキルを作成し、魔法使いに覚えさせると、どうなるでしょう？

```
主人公: 「魔法使い、ドラゴンを倒して」
魔法使い: 「ドラゴンの巣穴への行き方は・・・」
```

**魔法使いが混乱して道案内をし始めました。**
スキルを詰め込みすぎると、本来の役割がぼやけてしまいます。

### 道案内人の登場 - 役割を分ける

そこで「道案内人」という別のサブエージェントを作ります。

**サブエージェント: 道案内人**
- 役割: モンスターの居場所を調べて案内する
- 使えるスキル: ドラゴンの巣穴を見つける、ゴーレムの洞窟を見つける、海底神殿を見つける

```
あなた: 「道案内人にドラゴンの居場所を聞いて」
主人公: 「了解！」
主人公: 「道案内人、ドラゴンの居場所を教えて」
道案内人: 「北の火山にいます」

あなた: 「魔法使いに北の火山のドラゴンを倒させて」
主人公: 「魔法使い、北の火山のドラゴンを倒して」
魔法使い: （北の火山に向かう → サンダー魔法発動）

ドラゴン: 「ぐわあああ！」
```
![](/images/claude-code-game-analogy/image_9.jpeg)

**役割を分けたことで、それぞれが得意なことに専念できるようになりました！**

魔法使いは魔法攻撃に専念し、道案内は道案内人に任せる。これがSubagentを複数使う利点です。

でも、毎回「道案内人に聞いて」「魔法使いに攻撃させて」と全て指示するのは面倒ですね。

## 全てをまとめる - Commandで連携させる

最後に、これらを連携させるコマンドを作ります。

**コマンド: `/hunt [モンスター名]`**
- 実行される処理:
  1. 道案内人にモンスターの居場所を聞く
  2. その場所に魔法使いを連れて行く
  3. 魔法使いに攻撃させる

これで：

```
あなた: 「/hunt ドラゴン」

道案内人: 「北の火山にいます」
魔法使い: （火山に向かう）
魔法使い: （サンダー魔法発動）

ドラゴンを倒した！
```

**たった一言で、ドラゴンを倒せるようになりました。**

```md:.claude/commands/hunt.md
---
description: モンスターを探して倒す
argument-hint: [monster]
---

$ARGUMENTS を探して倒してください。

1. 道案内人に $ARGUMENTS の居場所を聞く
2. 魔法使いをその場所に向かわせる
3. 魔法使いに $ARGUMENTS の弱点の魔法で攻撃させる
```

:::details 現実世界での例
PRを作成する一連の流れをコマンド化できます：

```md:.claude/commands/pr.md
---
description: 変更をプッシュしてPRを作成する
argument-hint: [title]
allowed-tools: Bash(git:*), Bash(gh:*)
---

PRを作成してください。タイトルは「$ARGUMENTS」です。

1. コードレビュアーに変更をチェックさせる
2. 問題がなければ `git push` する
3. `gh pr create --title "$ARGUMENTS"` でPRを作成
```

「/pr 機能追加」の一言で、レビュー→プッシュ→PR作成まで自動化できます。
:::

## 新エリアへの冒険 - Rulesの登場

火山のドラゴンを倒せるようになったあなたは、新しいエリアに足を踏み入れます。

```
あなた: 「/hunt リヴァイアサン」

道案内人: 「海底神殿にいます」
魔法使い: （海底神殿に向かう）
魔法使い: （溺れる）
```

![](/images/claude-code-game-analogy/image_8.jpeg)

**魔法使いは泳げませんでした。**

海底エリアには「泳ぐスキルが必要」というルールがあったのです。火山エリアには「耐熱装備が必要」、氷の洞窟には「防寒対策が必要」...エリアごとに異なるルールがあります。

でも、全てのルールを仲間全員に毎回伝えるのは大変です。

### 道の看板を立てる

そこで、各エリアの入り口に**看板**を立てることにしました。

```md:.claude/rules/underwater.md
---
paths: world/underwater/**
---

# 海底エリアのルール
海の中なので溺れてしまいます。

## 必須条件
- 泳ぐスキルを発動すること

## 魔法の効果
- サンダー魔法: 威力半減（水中では危険）
- ブリザド魔法: 威力2倍（水棲系に有効）

## 注意事項
- 素早く動けないので回避より防御重視
```

これがClaude Codeでいう**Rules（ルール）** です。

看板を立てておけば、仲間たちはエリアに入るときに自動で看板を読んでくれます。

```
あなた: 「/hunt リヴァイアサン」

道案内人: 「海底神殿にいます」
魔法使い: （海底エリアの看板を読む）
魔法使い: 「泳ぐスキルを発動...ブリザド魔法で攻撃します」

リヴァイアサン: 「ぐわあああ！」
```
![](/images/claude-code-game-analogy/image_7.jpeg)

**エリアごとの注意事項を、自動で守ってくれるようになりました！**

### Rulesのポイント

- 特定のエリア（ファイルパス）に適用されるルール
- そのエリアに入ったときだけ自動で読み込まれる（他のエリアのことは忘れていい）
- 仲間（エージェント）に毎回伝えなくていい

:::details 現実世界での例
フロントエンドとバックエンドで異なるルールを設定できます：

```md:.claude/rules/frontend.md
---
paths: src/components/**
---

# フロントエンド開発ルール

## 使用技術
- React + TypeScript
- Tailwind CSSでスタイリング

## コンポーネント設計
- 1ファイル1コンポーネント
- Propsは型定義必須
```

`src/components/` を触るときはこのルールが自動で適用されます。
:::

Claude Code では、`.claude/rules/` にルールを定義します。

## 拡張と改善のイメージ

この考え方で、それぞれ柔軟に拡張できます。

**新しい敵に対応したい**
→ 戦士サブエージェントを追加して、物理攻撃に強い敵を担当させる
**もっと効率よく倒したい**
→ 魔法使いの数や、新たな仲間を増やして任せる量を増やす
→ `/hunt` コマンドをさらに拡張して、２つ以上のモンスターを同時に倒せるようにする。
**攻撃力を上げたい**
→ 「サンダー魔法」スキルを「上位サンダー魔法」にアップグレード
**新しいエリアに行きたい**
→ そのエリア用のRulesを追加して、必要なルールを書き込む


## CLAUDE.mdには何を書く？

ここまでCommand、Skill、Subagent、Rulesを紹介してきました。

では最後に、**CLAUDE.md**には何を書けばいいのでしょうか？

答えは「**世界観**」です。

| 項目 | ゲームの世界観 | CLAUDE.mdに書くこと |
|------|--------------|-------------------|
| **目的** | 「モンスターを倒していくRPGです」 | プロダクトの目的 |
| **前提** | 「冒険の舞台は中世ファンタジー」 | 使用技術 |
| **構成** | 「火山、海底、氷の洞窟などのエリアがある」 | ディレクトリ構成 |
| **設定** | 「モンスターにはエリア・HP・弱点がある」 | データ構造・命名規則 |
| **仲間** | 「魔法使いや道案内人がいる」 | 利用可能なサブエージェント ※ |
| **能力** | 「サンダー魔法や道案内のスキルがある」 | 利用可能なスキル ※ |
| **スタイル** | 「主人公は勇気ある行動をする」 | コーディングスタイル・話し方 |

※ 実際にはスキルやサブエージェントは `.claude/skills/` や `.claude/agents/` に配置すれば**自動発見**されます。CLAUDE.mdに書かなくても使えますが、重要なものや頻度が高いものは使用する確率を上げるために書いておくのもアリです。「どんな時に使うか」は各定義ファイルの `description` に書きましょう。

これらは特定のエリアだけでなく、**冒険全体を通じて常に適用される前提条件**です。

海底エリアにいても、火山にいても、「魔法が存在する」という世界観は変わりません。だからCLAUDE.mdに書くのです。

```md:CLAUDE.md

# プロダクトの目的
ドラゴンを売るECサイト

# 使用技術
- Node.js + TypeScript
- PostgreSQL
- Hono

# ディレクトリ構成
- src/api/ - APIエンドポイント
- src/models/ - データモデル
- src/services/ - ビジネスロジック
- tests/ - テストコード

# データ構造
- モデルには必ず id, createdAt, updatedAt を持たせる
- APIレスポンスは { data, error, meta } の形式

# 利用可能なサブエージェント
- code-reviewer: コードレビューを担当
- test-writer: テストコードを書く

# 利用可能なスキル
- eslint-check: ESLintでコードをチェック
- type-check: TypeScriptの型チェック

# コーディングスタイル
- 日本語でコメントを書く
- 関数名は動詞から始める
```

Claude Code では、プロジェクトルートに `CLAUDE.md` を置きます。


## まとめ

| 機能 | 例え | 定義するもの | 使うとき |
|------|------|-------------|----------|
| **CLAUDE.md** | 世界観 | 前提条件 | 常に適用される設定やルール |
| **Rules** | 道の看板 | パス別の前提 | パスごとに異なる設定やルール |
| **Command** | /attack | 何をやるか | よく使う指示をまとめたい |
| **Skill** | サンダー魔法 | どうやるか | 複雑な手順・知識を定義したい |
| **Subagent** | 魔法使い | どんな専門家か | 委託したい/並列実行したい |


あなたのAI冒険の旅が、より効率的になりますように！
