---
title: "ドラゴンを倒して覚える Claude Code - Command, Skill, Subagent, Rules"
emoji: "🎮"
type: "tech"
topics: ["claudecode", "llm", "ai"]
published: true
---

## この記事を読むべき人

Claude Code をカスタマイズしようとして、こんな経験はありませんか？

- 「このルール、CLAUDE.md に書く？Skill に書く？」と手が止まる
- Command を作ったのに、結局 Skill との違いがわからない
- Subagent の存在は知っているけど、いつ使うか判断できない

そして最近、**Rules** という概念まで登場しましたね。「また増えた...これどこに書くの？」

公式ドキュメントを読んでも、**概念の使い分け**がピンとこない。そんな人のために、RPGゲームで例えてみました。

:::message
この記事で扱う概念の公式ドキュメントはこちら:
- [Custom slash commands（Command）](https://code.claude.com/docs/en/slash-commands)
- [Agent Skills（Skill）](https://code.claude.com/docs/en/skills)
- [Subagents](https://code.claude.com/docs/en/sub-agents)
- [Modular rules（Rules）](https://code.claude.com/docs/en/memory#modular-rules-with-claude/rules/)
:::

## 冒険の始まり - あなたはプレイヤー

![](/images/claude-code-game-analogy/image_2.jpeg)

あなたはモンスターを倒すRPGをプレイしています。

画面の中には主人公のキャラクターがいます。あなたはプレイヤーとして、この主人公に指示を出してゲームを進めます。

**Claude Code で言うと：**
- **あなた（プレイヤー）** = ユーザー
- **主人公** = メインエージェント（Claude）

主人公は優秀なので、ざっくりした指示でも動いてくれます。ただし、毎回確認してきたり、考え込んだりします。

## 最初のモンスター - 毎回の確認が面倒

![](/images/claude-code-game-analogy/image_3.jpeg)

フィールドにスライムが現れました。

```
あなた: 「スライムを倒して」

主人公: 「武器は何を使いますか？剣、槍、斧がありますが...」
あなた: 「剣で」

主人公: 「わかりました。まず敵との距離を確認します...」
主人公: 「3歩近づく必要がありますね」
主人公: （3歩歩く）
主人公: 「では攻撃します」
主人公: （剣で攻撃）

スライムを倒した！
```

倒せました。でも、毎回これだと時間がかかります。

スライムを見るたびに「武器は？」「距離を確認して...」とやっていては、冒険が進みません。

## Commandの登場 - 確認なしで動かす

そこで「攻撃」というコマンドを作ります。

**コマンド: `/attack`**
- 事前に決めておく指示:
  - 武器は剣を使う（確認不要）
  - 敵に近づいて攻撃する（説明不要）

これで、スライムが現れたら：

```
あなた: 「/attack」
主人公: （すぐに剣で攻撃）

スライムを倒した！
```

**確認も説明もなく、すぐに攻撃してくれました！**

これでスライムが何匹現れても、`/attack` の一言で倒せます。快適です。

**Commandのポイント**:
- 毎回の確認や説明をスキップできる
- 指示は**主人公（メインエージェント）に対して**行われる
- 引数を渡すこともできる（例: `/attack スライム`）

```md:.claude/commands/attack.md
# 攻撃コマンド

敵を攻撃する。確認は不要。

## 手順
1. 剣を装備する
2. 敵に近づく
3. 攻撃する
```

:::details 現実世界での例
git操作をコマンド化しておけば、毎回の確認をスキップできます：

```md:.claude/commands/commit.md
# コミットコマンド

変更をコミットする。

## 手順
1. `git add .` で全ファイルをステージング
2. 変更内容を確認してコミットメッセージを作成
3. `git commit` を実行

## 注意
- コミットメッセージは日本語で書く
- 1コミット1機能を守る
```

「/commit」の一言で、いつも同じ手順でコミットしてくれます。
:::

Claude Code では、`.claude/commands/` にコマンドを定義します。

## ドラゴンの登場 - 剣が効かない敵

スライムは簡単に倒せるようになりました。

さて、次はドラゴンを倒しに行きます。

```
あなた: 「ドラゴンを倒して」
主人公: 「...どこにいるんですか？」
```

主人公はドラゴンの居場所を知りません。

仕方なく、あなたは道案内をしながらドラゴンの巣穴まで連れて行きました。

```
あなた: 「北に10歩、東に5歩、洞窟に入って...」
主人公: （ようやくドラゴンの前に到着）

あなた: 「/attack」
主人公: （剣で攻撃）

ドラゴン: 「効かぬわ！」
```
![](/images/claude-code-game-analogy/image_4.jpeg)

剣では倒せません。主人公は調査をし見つけました。
ドラゴンには**サンダー魔法が弱点**だったのです。

## Skillの登場 - 特殊な能力を定義する

サンダー魔法を使うには、長い呪文を唱える必要があります。

```
あなた: 「インフィニティ・ライトニング・ストーム・
        アブソリュート・サンダー・ボルテージ・
        エクスプロージョン...」（まだまだ続く）

主人公: （サンダー魔法発動）
```

毎回これを言うのは大変すぎます。

そこで「サンダー魔法」というスキルを作ります。

```md:.claude/skills/thunder-magic/SKILL.md
---
name: thunder-magic
description: 雷属性の強力な魔法攻撃。ドラゴンに有効。
---

# サンダー魔法

## 詠唱の手順
1. 魔力を右手に集中させる
2. 「インフィニティ・ライトニング・ストーム...」と唱える
3. 雷雲が集まったら解放する

## 発動条件
- 魔力が十分にあること
- 屋外または天井が高い場所

## 効果
- 雷属性の攻撃を行う
- ドラゴン系に特効（2倍ダメージ）
```

これで：

```
あなた: 「サンダー魔法を使って」
主人公: （スキルを参照して、サンダー魔法発動）

ドラゴン: 「ぐわあああ！」
```

![](/images/claude-code-game-analogy/image_5.jpeg)
**ついにドラゴンを倒せました！**

長い呪文を覚えなくても、「サンダー魔法を使って」の一言で倒せます。

**Skillのポイント**:
- 複雑な手順や専門知識をまとめて定義できる
- 主人公に「どうやるか」を詳しく教えなくても、スキル名だけで実行できる
- サンダー魔法を使う時以外には、呪文を覚える必要がない（コンテキスト節約）

:::details 現実世界での例
gitのコミットメッセージの書き方は人やプロジェクトによって異なります。スキルとして定義しておけば：

```md:.claude/skills/git-commit-message/SKILL.md
---
name: git-commit-message
description: gitコミットメッセージの作成ルール
---

# コミットメッセージのルール

## フォーマット
- 1行目: 変更内容の要約（50文字以内）
- 2行目: 空行
- 3行目以降: 詳細な説明（必要に応じて）

## プレフィックス
- `feat:` 新機能
- `fix:` バグ修正
- `docs:` ドキュメント変更
- `refactor:` リファクタリング
```

「コミットして」というだけで、このルールに従ってコミットしてくれます。
:::

Claude Code では、`.claude/skills/` にスキルを定義します。

## 初めてのSubagent - 魔法使いを仲間にする

サンダー魔法でドラゴンを倒せるようになりました。

しかし、ドラゴンはたくさんいます。主人公を操作して1匹ずつ倒しに行くのは効率が悪い。

そこで、あなたはパーティに新しい仲間を加えることにしました。

「魔法が得意な**魔法使い**を雇おう」

この魔法使いは、主人公とは別に動くキャラクターです。これがClaude Codeでいう**Subagent（サブエージェント）** です。

**サブエージェント: 魔法使い**
- 役割: 魔法で敵を攻撃することが得意
- 使えるスキル:
  - サンダー魔法
  - ファイアー魔法
  - ブリザド魔法

あなたは主人公に「魔法使いにドラゴンを倒させて」と指示します。

```
あなた: 「魔法使いにドラゴンを倒させて」
主人公: 「了解！」
主人公: 「魔法使い、ドラゴンを倒して」
魔法使い: （サンダー魔法発動）

ドラゴン: 「ぐわあああ！」
```

**魔法使いが自分でスキルを選んで、ドラゴンを倒してくれました！**

...と、うまくいけばいいのですが。

### 問題発生 - 魔法の選び方がわからない

実際には、こうなることがあります。

```
あなた: 「魔法使いにドラゴンを倒させて」
主人公: 「了解！」
主人公: 「魔法使い、ドラゴンを倒して」
魔法使い: （ファイアー魔法発動）

ドラゴン: 「火は効かぬわ！」
```

あれ？魔法使いはファイアー魔法を使ってしまいました。

魔法は使えるけど、**どの敵にどの魔法が効くか**までは知らないのです。

### Subagentに「振る舞い」を追加する

そこで、魔法使いの設定に少しルールを書き足します。

**サブエージェント: 魔法使い（改善版）**
- 役割: 魔法で敵を攻撃することが得意
- 使えるスキル: サンダー魔法、ファイアー魔法、ブリザド魔法
- **振る舞い:**
  - ドラゴンにはサンダー魔法を優先
  - ゴーレムにはファイアー魔法を優先
  - 水棲系にはブリザド魔法を優先

これだけで、あなたはこう言うだけで良くなります。

```
あなた: 「魔法使いにドラゴンを倒させて」
主人公: 「了解！」
主人公: 「魔法使い、ドラゴンを倒して」
魔法使い: （相手はドラゴン → 弱点はサンダー → サンダー魔法発動）

ドラゴン: 「ぐわあああ！」
```

**適切な魔法を自分で判断して攻撃してくれるようになりました！**

Claude Code では、`.claude/agents/` にサブエージェントを定義します：

```md:.claude/agents/mage.md
---
name: mage
description: 魔法で敵を攻撃する。ドラゴン、ゴーレム、水棲系モンスターとの戦闘で使用する。
tools: Read, Bash
skills: thunder-magic, fire-magic, blizzard-magic
---

あなたは魔法攻撃の専門家です。

## 振る舞い
- ドラゴンにはサンダー魔法を優先
- ゴーレムにはファイアー魔法を優先
- 水棲系にはブリザド魔法を優先

敵の弱点を見極めて、最適な魔法を選択してください。
```

:::details 現実世界での例
コードレビューを担当するサブエージェントを定義できます：

```md:.claude/agents/code-reviewer.md
---
name: code-reviewer
description: コードの品質をチェックする。PR作成前やコード変更後に使用する。
tools: Read, Grep, Glob, Bash
skills: eslint-check, type-check, security-scan
---

あなたはコードレビューの専門家です。

## レビュー手順
1. まずeslint-checkでスタイルをチェック
2. 次にtype-checkで型エラーを確認
3. 最後にsecurity-scanで脆弱性をスキャン

## 出力形式
- 問題があれば具体的な修正案を提示
- 重大度（高/中/低）を明示
- 該当行番号を含める
```

「コードをレビューして」と言えば、この手順で自動的にレビューしてくれます。
:::

**Subagentのポイント**:
- 特定の役割を持つ専門家を定義できる
- 主人公（メインエージェント）とは別に動く仲間（コンテキストが独立）
- 複数のスキルを組み合わせて使える
- 振る舞いを定義して、適切な判断をさせられる
- 並列で動かせる


### 並列処理 - Subagentの真価

魔法使いが適切な魔法を選んでくれるようになりました。

しかし、ドラゴンは10匹います。1匹ずつ倒していくと...

```
あなた: 「魔法使いにドラゴンを倒させて」
主人公: 「了解！」
主人公: 「魔法使い、ドラゴンを倒して」
魔法使い: （サンダー魔法発動）
ドラゴン1: 「ぐわあああ！」

あなた: 「次のドラゴンも倒させて」
主人公: 「魔法使い、次のドラゴンを倒して」
魔法使い: （サンダー魔法発動）
ドラゴン2: 「ぐわあああ！」

...（あと8回繰り返す）
```

**10匹倒すのに、10回待たないといけません。** 時間がかかりすぎます。

ここで、**Subagentの最大の強み**を紹介します。それは**並列で動かせる**ことです。

```
あなた: 「魔法使い10人でドラゴンを全部倒させて」
主人公: 「了解！魔法使い10人、それぞれドラゴンを倒して！」

魔法使いA: （サンダー魔法発動）
魔法使いB: （サンダー魔法発動）
魔法使いC: （サンダー魔法発動）
...（同時に10発）

ドラゴン10匹: 「」（全員即死）
```

![](/images/claude-code-game-analogy/image_6.jpeg)

**10匹のドラゴンを一瞬で倒せました！**

主人公1人では1回ずつしか攻撃できませんが、サブエージェントを複数召喚すれば並列で処理できます。

## 新たな問題 - 道案内

ドラゴンを効率よく倒せるようになりました。

でも、まだ問題があります。魔法使いはドラゴンの**居場所**を知りません。

```
あなた: 「魔法使いにドラゴンを倒させて」
主人公: 「了解！」
主人公: 「魔法使い、ドラゴンを倒して」
魔法使い: 「どこにいるんですか？」
```


### 役割の分離 - 専門家を増やす
「ドラゴンの場所を見つけるスキル」を魔法使いに覚えさせることもできます。

しかし、モンスターはドラゴンだけではありません。
- ゴーレムの居場所
- リヴァイアサンの居場所
- スライムの居場所
- ...

全てのモンスターの道案内スキルを作成し、魔法使いに覚えさせると、どうなるでしょう？

```
主人公: 「魔法使い、ドラゴンを倒して」
魔法使い: 「ドラゴンの巣穴への行き方は・・・」
```

**魔法使いが混乱して道案内をし始めました。**
スキルを詰め込みすぎると、本来の役割がぼやけてしまいます。

### 道案内人の登場 - 役割を分ける

そこで「道案内人」という別のサブエージェントを作ります。

**サブエージェント: 道案内人**
- 役割: モンスターの居場所を調べて案内する
- 使えるスキル: ドラゴンの巣穴を見つける、ゴーレムの洞窟を見つける、海底神殿を見つける

```
あなた: 「道案内人にドラゴンの居場所を聞いて」
主人公: 「了解！」
主人公: 「道案内人、ドラゴンの居場所を教えて」
道案内人: 「北の火山にいます」

あなた: 「魔法使いに北の火山のドラゴンを倒させて」
主人公: 「魔法使い、北の火山のドラゴンを倒して」
魔法使い: （北の火山に向かう → サンダー魔法発動）

ドラゴン: 「ぐわあああ！」
```

**役割を分けたことで、それぞれが得意なことに専念できるようになりました！**

魔法使いは魔法攻撃に専念し、道案内は道案内人に任せる。これがSubagentを複数使う利点です。

でも、毎回「道案内人に聞いて」「魔法使いに攻撃させて」と2回指示するのは面倒ですね。

## 全てをまとめる - Commandで連携させる

最後に、これらを連携させるコマンドを作ります。

**コマンド: `/hunt [モンスター名]`**
- 実行される処理:
  1. 道案内人にモンスターの居場所を聞く
  2. その場所に魔法使いを連れて行く
  3. 魔法使いに攻撃させる

これで：

```
あなた: 「/hunt ドラゴン」

道案内人: 「北の火山にいます」
魔法使い: （火山に向かう）
魔法使い: （サンダー魔法発動）

ドラゴンを倒した！
```

**たった一言で、ドラゴンを倒せるようになりました。**

```md:.claude/commands/hunt.md
# 狩りコマンド

モンスターを探して倒す。

## 引数
- $MONSTER: 倒したいモンスターの名前

## 手順
1. 道案内人に $MONSTER の居場所を聞く
2. 魔法使いをその場所に向かわせる
3. 魔法使いに攻撃させる

## サブエージェント
- 道案内人: 居場所を調べる
- 魔法使い: 攻撃を担当
```

:::details 現実世界での例
PRを作成する一連の流れをコマンド化できます：

```md:.claude/commands/pr.md
# PRコマンド

変更をプッシュしてPRを作成する。

## 引数
- $TITLE: PRのタイトル

## 手順
1. コードレビュアーに変更をチェックさせる
2. 問題がなければ `git push` する
3. `gh pr create --title "$TITLE"` でPRを作成

## サブエージェント
- コードレビュアー: 品質チェックを担当
```

「/pr 機能追加」の一言で、レビュー→プッシュ→PR作成まで自動化できます。
:::

## 新エリアへの冒険 - Rulesの登場

火山のドラゴンを倒せるようになったあなたは、新しいエリアに足を踏み入れます。

```
あなた: 「/hunt リヴァイアサン」

道案内人: 「海底神殿にいます」
魔法使い: （海底神殿に向かう）
魔法使い: （溺れる）
```

![](/images/claude-code-game-analogy/image_8.jpeg)

**魔法使いは泳げませんでした。**

海底エリアには「呼吸スキルが必要」というルールがあったのです。火山エリアには「耐熱装備が必要」、氷の洞窟には「防寒対策が必要」...エリアごとに異なるルールがあります。

でも、全てのルールを仲間全員に毎回伝えるのは大変です。

### 道の看板を立てる

そこで、各エリアの入り口に**看板**を立てることにしました。

```md:.claude/rules/underwater.md
---
paths: world/underwater/**
---

# 海底エリアのルール

## 必須条件
- 呼吸スキルを発動すること

## 魔法の効果
- サンダー魔法: 威力半減（水中では危険）
- ブリザド魔法: 威力2倍（水棲系に有効）

## 注意事項
- 素早く動けないので回避より防御重視
```

これがClaude Codeでいう**Rules（ルール）** です。

看板を立てておけば、仲間たちはエリアに入るときに自動で看板を読んでくれます。

```
あなた: 「/hunt リヴァイアサン」

道案内人: 「海底神殿にいます」
魔法使い: （海底エリアの看板を読む）
魔法使い: 「呼吸スキルを発動...ブリザド魔法で攻撃します」

リヴァイアサン: 「ぐわあああ！」
```
![](/images/claude-code-game-analogy/image_7.jpeg)

**エリアごとの注意事項を、自動で守ってくれるようになりました！**

### Rulesのポイント

- 特定のエリア（ファイルパス）に適用されるルール
- そのエリアに入ったときだけ自動で読み込まれる
- 仲間（エージェント）に毎回伝えなくていい

:::details 現実世界での例
フロントエンドとバックエンドで異なるルールを設定できます：

```md:.claude/rules/frontend.md
---
paths: src/components/**
---

# フロントエンド開発ルール

## 使用技術
- React + TypeScript
- Tailwind CSSでスタイリング

## コンポーネント設計
- 1ファイル1コンポーネント
- Propsは型定義必須
```

`src/components/` を触るときはこのルールが自動で適用されます。
:::

Claude Code では、`.claude/rules/` にルールを定義します。

## 拡張と改善

この仕組みは柔軟に拡張できます。

### 新しい敵に対応したい
→ 戦士サブエージェントを追加して、物理攻撃に強い敵を担当させる

### 効率を上げたい
→ 魔法使いや道案内人の数を増やして並列処理を強化

### 攻撃力を上げたい
→ 「サンダー魔法」スキルを「上位サンダー魔法」にアップグレード

### 新しいモンスターに対応したい
→ 道案内人に新しい居場所スキルを追加


## CLAUDE.mdには何を書く？

ここまでCommand、Skill、Subagent、Rulesを紹介してきました。

では最後に、**CLAUDE.md**には何を書けばいいのでしょうか？

答えは「**世界観**」です。

| 項目 | ゲームの世界観 | CLAUDE.mdに書くこと |
|------|--------------|-------------------|
| **目的** | 「モンスターを倒していくRPGです」 | プロダクトの目的 |
| **前提** | 「冒険の舞台は中世ファンタジー」 | 使用技術（土台となる、ほぼ変わらない） |
| **構成** | 「火山、海底、氷の洞窟などのエリアがある」 | ディレクトリ構成 |
| **設定** | 「モンスターにはエリア・HP・弱点がある」 | データ構造・命名規則 |
| **仲間** | 「魔法使いや道案内人がいる」 | 利用可能なサブエージェント ※ |
| **能力** | 「サンダー魔法や道案内のスキルがある」 | 利用可能なスキル ※ |
| **スタイル** | 「主人公は勇気ある行動をする」 | コーディングスタイル・話し方 |

※ 実際にはスキルやサブエージェントは `.claude/skills/` や `.claude/agents/` に配置すれば**自動発見**されます。CLAUDE.mdに書かなくても使えますが、重要なものはプロジェクトの全体像を把握するために書いておくと便利です。「どんな時に使うか」はスキル定義ファイルの `description` に書きましょう。

これらは特定のエリアだけでなく、**冒険全体を通じて常に適用される前提条件**です。

海底エリアにいても、火山にいても、「魔法が存在する」という世界観は変わりません。だからCLAUDE.mdに書くのです。

```md:CLAUDE.md

# プロダクトの目的
ドラゴンを売るECサイト

# 使用技術
- Node.js + TypeScript
- PostgreSQL
- Hono

# ディレクトリ構成
- src/api/ - APIエンドポイント
- src/models/ - データモデル
- src/services/ - ビジネスロジック
- tests/ - テストコード

# データ構造
- モデルには必ず id, createdAt, updatedAt を持たせる
- APIレスポンスは { data, error, meta } の形式

# 利用可能なサブエージェント
- code-reviewer: コードレビューを担当
- test-writer: テストコードを書く

# 利用可能なスキル
- eslint-check: ESLintでコードをチェック
- type-check: TypeScriptの型チェック

# コーディングスタイル
- 日本語でコメントを書く
- 関数名は動詞から始める
```

Claude Code では、プロジェクトルートに `CLAUDE.md` を置きます。


## まとめ

![](/images/claude-code-game-analogy/image_8.jpeg)

| 概念 | ゲームでの例え | 役割 |
|------|---------------|------|
| **CLAUDE.md** | 世界観 | 常に適用される前提条件 |
| **Command** | /attack, /hunt | よく使う指示をまとめる。引数を受け取れる |
| **Skill** | サンダー魔法、道案内 | 複雑な手順や専門知識を定義する |
| **Subagent** | 魔法使い、道案内人 | 特定の役割を持つ仲間。並列実行できる |
| **Rules** | 道の看板 | エリア（パス）ごとの自動適用ルール |


あなたのAI冒険の旅が、より効率的になりますように！
